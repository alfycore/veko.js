#!/usr/bin/env node

const path = require('path');
const fs = require('fs');

// Message d'installation si l'utilisateur essaie d'utiliser npx veko-update
if (process.argv[1].includes('npx')) {
  console.log('\nüöÄ Veko Auto-Updater\n');
  console.log('Il semble que vous utilisez npx pour ex√©cuter cet outil.');
  console.log('Pour une meilleure exp√©rience, installez veko globalement :\n');
  console.log('  npm install -g veko');
  console.log('\nPuis utilisez la commande :\n');
  console.log('  veko update\n');
  console.log('Ou si vous pr√©f√©rez ne pas installer globalement :\n');
  console.log('  npx veko update\n');
}

// Ajouter le chemin vers les modules lib
const libPath = path.join(__dirname, '..', 'lib');
process.env.NODE_PATH = `${process.env.NODE_PATH || ''}:${libPath}`;
require('module')._initPaths();

// Importer l'auto-updater avec gestion des erreurs
let AutoUpdater = null;
try {
    AutoUpdater = require('../lib/core/auto-updater');
} catch (error) {
    console.error(`Erreur de chargement de l'auto-updater: ${error.message}`);
    console.error('Veko fonctionnera sans auto-updater');
    process.exit(1);
}

async function main() {
    const args = process.argv.slice(2);
    const command = args[0];

    try {
        // V√©rification de la disponibilit√© avant l'ex√©cution
        if (!AutoUpdater) {
            throw new Error("L'auto-updater n'est pas disponible");
        }

        // D√©tecter si nous sommes dans un environnement non-interactif ou CI
        const isNonInteractive = !process.stdin.isTTY || process.env.CI === 'true';
        
        // D√©finir un timeout global pour √©viter les blocages
        const commandTimeout = setTimeout(() => {
            console.error("‚ùå Timeout - La commande prend trop de temps √† s'ex√©cuter");
            process.exit(1);
        }, 60000); // 1 minute maximum
        
        // Ajouter un gestionnaire SIGINT pour le Ctrl+C
        const sigintHandler = () => {
            console.log("\nüëã Op√©ration annul√©e par l'utilisateur");
            clearTimeout(commandTimeout);
            process.exit(0);
        };
        process.on('SIGINT', sigintHandler);

        try {
            switch (command) {
                case undefined:
                case 'menu':
                    // Menu interactif par d√©faut avec d√©tection d'environnement
                    if (isNonInteractive) {
                        console.log('[Auto-updater] Environnement non-interactif d√©tect√©');
                        console.log('Ex√©cution automatique de "check" en mode non-interactif');
                        await AutoUpdater.checkForUpdates(false);
                    } else {
                        await AutoUpdater.interactive();
                    }
                    break;
                    
                case 'check':
                    console.log('üîç V√©rification des mises √† jour...');
                    const updateInfo = await AutoUpdater.checkForUpdates(false);
                    // R√©sultat d√©j√† affich√© par la fonction checkForUpdates
                    break;

                case 'update':
                    console.log('üöÄ Mise √† jour en cours...');
                    const success = await AutoUpdater.checkAndUpdate();
                    if (success) {
                        console.log('‚úÖ Mise √† jour termin√©e avec succ√®s!');
                    } else {
                        console.log('‚ùå √âchec de la mise √† jour.');
                        process.exit(1);
                    }
                    break;

                case 'status':
                    await AutoUpdater.displayStats();
                    break;

                case 'fix':
                    console.log('üîß Tentative de r√©paration de l\'auto-updater...');
                    await fixAutoUpdater();
                    break;

                // ...autres commandes existantes...
                
                default:
                    if (typeof AutoUpdater.handleCLI === 'function') {
                        await AutoUpdater.handleCLI(args);
                    } else {
                        console.log(`‚ùå Commande inconnue: ${command}`);
                        showHelp();
                        process.exit(1);
                    }
            }
        } finally {
            // Nettoyage
            clearTimeout(commandTimeout);
            process.removeListener('SIGINT', sigintHandler);
            
            // Fermeture propre des interfaces et connexions
            if (AutoUpdater && typeof AutoUpdater.closeReadline === 'function') {
                AutoUpdater.closeReadline();
            }
        }
        
    } catch (error) {
        console.error(`‚ùå Erreur: ${error.message}`);
        
        // Sugg√©rer la commande de r√©paration
        console.log('\nPour r√©parer automatiquement l\'auto-updater, essayez:');
        console.log('npx veko update fix');
        
        if (process.env.DEBUG) {
            console.error(error.stack);
        }
        process.exit(1);
    }
}

// Fonction de d√©pannage de l'auto-updater
async function fixAutoUpdater() {
    console.log('1. V√©rification des r√©pertoires...');
    try {
        const backupDir = path.join(process.cwd(), '.veko-backups');
        if (!fs.existsSync(backupDir)) {
            fs.mkdirSync(backupDir, { recursive: true });
            console.log('‚úÖ R√©pertoire de backup cr√©√©');
        }
        
        console.log('2. R√©initialisation de la configuration...');
        const configPath = path.join(process.cwd(), '.veko-updater.json');
        const defaultConfig = {
            autoCheck: true,
            autoUpdate: false,
            checkInterval: 3600000,
            backupCount: 5,
            securityCheck: true,
            progressBar: true,
            notifications: true,
            rollbackOnFailure: true,
            updateChannel: 'stable'
        };
        
        fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));
        console.log('‚úÖ Configuration r√©initialis√©e');
        
        console.log('3. Nettoyage des fichiers temporaires...');
        const pidFile = path.join(process.cwd(), '.veko-updater.pid');
        if (fs.existsSync(pidFile)) {
            fs.unlinkSync(pidFile);
            console.log('‚úÖ Fichier PID supprim√©');
        }
        
        console.log('\n‚úÖ Auto-updater r√©par√© avec succ√®s!');
        console.log('Vous pouvez maintenant utiliser: npx veko-update');
    } catch (error) {
        console.error(`‚ùå Erreur pendant la r√©paration: ${error.message}`);
        throw error;
    }
}

function showHelp() {
    console.log(`
üöÄ Veko Auto-Updater - Le plus avanc√© des auto-updaters Node.js

Usage: npx veko-update [command] [options]

Commandes:
  (aucune)          üé® Ouvre le menu interactif (recommand√©)
  check             üîç V√©rifier les mises √† jour
  update            ‚ö° Mettre √† jour maintenant
  status            üìä Afficher le statut actuel
  config            ‚öôÔ∏è Configurer l'auto-updater
  rollback [backup] üîÑ Effectuer un rollback
  stats             üìà Afficher les statistiques d√©taill√©es
  backup            üíæ G√©rer les backups
  daemon            üëæ D√©marrer en mode daemon (arri√®re-plan)
  stop              üõë Arr√™ter le daemon
  activate          üéØ Configuration initiale guid√©e
  fix               üîß R√©parer l'auto-updater
  help              ‚ùì Afficher cette aide
  version           üìã Afficher la version

Options:
  --verbose, -v     Sortie d√©taill√©e
  --force, -f       Forcer l'op√©ration
  --help, -h        Afficher l'aide
    `);
}

// Gestion gracieuse des signaux
process.on('SIGINT', () => {
    console.log('\nüëã Auto-updater interrompu par l\'utilisateur');
    if (AutoUpdater && typeof AutoUpdater.closeReadline === 'function') {
        try {
            AutoUpdater.closeReadline();
        } catch (err) {
            // Ignorer les erreurs pendant l'arr√™t
        }
    }
    process.exit(0);
});

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
    console.error('‚ùå Erreur non g√©r√©e:', error.message);
    if (process.env.DEBUG) {
        console.error(error.stack);
    }
    process.exit(1);
});

// Lancement de l'application avec gestion d'erreurs
main().catch((error) => {
    console.error(`‚ùå Erreur fatale: ${error.message}`);
    if (process.env.DEBUG) {
        console.error(error.stack);
    }
    process.exit(1);
});